package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {

        // Variables
        case Variable(name) => GetLocal(locals(name))

        // QST: Is it correctly pushed to stack? Should we convert value to Int?
        // Raoul: Yes, I think they should be Int
        // Literals
        case IntLiteral(value) => Const(value)
        case BooleanLiteral(false) => Const(0)
        case BooleanLiteral(true) => Const(1)
        case StringLiteral(value) => mkString(value)
        case UnitLiteral() => Const(0)

        // Binary operators
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> And
        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Or
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")

        // Unary operators
        case Not(e) => cgExpr(e) <:> Eqz
        case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub

        // Function/constructor call
        // W: see the "allocaing ADT values" on the provided pdf
        case AmyCall(name, args) =>
          table.getConstructor(name) match {
            case None => // no constructor found => function call
              args.map(cgExpr(_)) <:> Call(fullName(table.getFunction(name).get.owner, name))
            case Some(constr) =>
              val b = lh.getFreshLocal()
              
              GetGlobal(memoryBoundary) <:> SetLocal(b) <:> // save old memory boundary
              GetGlobal(memoryBoundary) <:> adtField(args.size) <:> SetGlobal(memoryBoundary) <:>  // increment the memory boundary
              GetLocal(b) <:> Const(constr.index) <:> Store <:>   // Store the constructor index
              (args.map(cgExpr(_)).zipWithIndex).map({case (arg, index) => GetLocal(b) <:> adtField(index) <:> arg <:> Store}) <:> // generate code for each field of the constructor and store it at correct offset
              GetLocal(b) // push b back to stack
          }
        

        // The ; operator
        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)

        // Local variable definition
        case Let(df, value, body) => {
          val newloc = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(newloc) <:> cgExpr(body)(locals + (df.name -> newloc), lh)
        }

        // If-then-else
        case Ite(cond, thenn, elze) =>
          cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End

        // Pattern matching
        case Match(scrutinee, cases) => {
          // see pdf of lab05 instructions
          def matchAndBind(v: Code, p: Pattern): (Code, Map[Identifier, Int]) = 
            p match {

              // evaluates to true
              case WildcardPattern() => (v <:> Drop <:> Const(1), locals)
              
              // true if v is equal to lit  
              case LiteralPattern(lit) => (v <:> cgExpr(lit) <:> Eq, locals)
              
              // evaluates to true and assigns v to id
              case IdPattern(name) =>
                val id = lh.getFreshLocal()
                (v <:> SetLocal(id) <:> Const(1), locals + (name -> id))
              
              case CaseClassPattern(name, args) =>
                val constrAddress = lh.getFreshLocal()

                // need to recursively match and bind the arguments of interior patterns
                val codeWithNewLocals: List[(Code, Map[Identifier, Int])] = args.zipWithIndex.map({case (pattern, index) => matchAndBind(GetLocal(constrAddress) <:> adtField(index) <:> Load, pattern)})
                
                // The corresponding code for our arguments, based on the number of arguments. W: Need to define as type code, otherwise error (Why?)
                val argCode : Code = {
                  if (args.isEmpty) Const(1)  // no args to evaluate, thus will evaluate to true
                  else if (args.length == 1) codeWithNewLocals.map(_._1) // only one arg to evaluate
                  else codeWithNewLocals.map(_._1) <:> {for (i <- 1 until args.length) yield And}.toList // multiple args, need to append and And for every subsequent argument
                }
                
                // code for the entire case class
                val caseClassCode: Code =
                    v <:> SetLocal(constrAddress) <:>                             // stores the temporary constructor (in order to compare the args)
                    GetLocal(constrAddress) <:> Load <:>                          // loads in back order to compare it
                    Const(table.getConstructor(name).get.index) <:> Eq <:>        // Checks whether same constructor name
                    If_i32 <:> argCode <:> Else <:> Const(0) <:> End              // checks whether the arguments are the same

                (caseClassCode, locals ++ codeWithNewLocals.map(_._2).foldLeft(Map[Identifier,Int]())(_ ++ _))
            }
          

          val scrutineeAddress = lh.getFreshLocal() 
          val boundCases = cases.map(c => (c.expr, matchAndBind(GetLocal(scrutineeAddress), c.pat)))

          (cgExpr(scrutinee) <:> SetLocal(scrutineeAddress) <:>                                                                 // evaluate the scrutinee and save it
          boundCases.map({case (expr, (code, cLocals)) => code <:> If_i32 <:> cgExpr(expr)(cLocals, lh) <:> Else}) <:>          // concatenate the code for each case with an "else"
          mkString("Matching error : ") <:> Call("Std_printString") <:> Unreachable <:> cases.map(cse => End))                  // if none of the cases match, reach a matching error
        }

        // Represents a computational error; prints its message, then exits
        case Error(str) => cgExpr(StringLiteral("Error : ")) <:> cgExpr(str) <:> Call(concatImpl.name) <:> Call("Std_printString") <:> Unreachable

        //In every other case, we do not have a correspondance, hence he program crashes
        case _ => mkString(s"Error : unknown expression encountered at ${expr.position.toString}")
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
